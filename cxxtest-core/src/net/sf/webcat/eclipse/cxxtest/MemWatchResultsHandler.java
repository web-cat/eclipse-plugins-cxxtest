package net.sf.webcat.eclipse.cxxtest;

import java.util.Vector;

import net.sf.webcat.eclipse.cxxtest.internal.model.CxxTestStackFrame;
import net.sf.webcat.eclipse.cxxtest.internal.model.MemWatchInfo;
import net.sf.webcat.eclipse.cxxtest.internal.model.MemWatchLeak;
import net.sf.webcat.eclipse.cxxtest.model.IMemWatchInfo;
import net.sf.webcat.eclipse.cxxtest.model.IMemWatchLeak;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

/**
 * This class is a very simplistic SAX content handler that parses the XML
 * results file generated by our CxxTest XML printer and builds a tree of
 * test suite and test case objects from it.
 */
public class MemWatchResultsHandler extends DefaultHandler
{
	private MemWatchInfo mwInfo = null;

	private Vector leaks = new Vector();

	private boolean insideLeak = false;

	private MemWatchLeak lastLeak = null;
	
	public void startElement(String uri, String localName, String qName,
			Attributes attributes)
	{
		if(localName.equals("summary"))
			startSummary(attributes);
		if(localName.equals("leak"))
			startLeak(attributes);
		else if(insideLeak)
			startStackFrame(attributes);
	}

	public void endElement(String uri, String localName, String qName)
	{
		if(localName.equals("leak"))
			endLeak();
	}
	
	private void startLeak(Attributes attributes)
	{
		MemWatchLeak leak = new MemWatchLeak(attributes);
		leaks.add(leak);
		lastLeak = leak;
		
		insideLeak = true;
	}
	
	private void endLeak()
	{
		insideLeak = false;
		lastLeak = null;
	}

	private void startStackFrame(Attributes attributes)
	{
		String function = attributes.getValue("function");
		String file = null;
		int lineNumber = 0;
		
		String fileLine = attributes.getValue("location");
		if(fileLine != null)
		{
			String[] parts = fileLine.split(":");
			file = parts[0];
			
			if(parts.length > 1)
				lineNumber = Integer.parseInt(parts[1]);
		}
		
		lastLeak.addStackFrame(new CxxTestStackFrame(function, file, lineNumber));
	}

	public IMemWatchInfo getInfo()
	{
		mwInfo.setLeaks((IMemWatchLeak[])leaks.toArray(
				new IMemWatchLeak[leaks.size()]));
		return mwInfo;
	}
	
	private int getAttrInt(Attributes attributes, String name)
	{
		return Integer.parseInt(attributes.getValue(name));
	}

	private void startSummary(Attributes attributes)
	{
		int maxBlocks = getAttrInt(attributes, "max-blocks");
		int callsNew = getAttrInt(attributes, "calls-to-new");
		int callsDelete = getAttrInt(attributes, "calls-to-delete");
		int callsNewArray = getAttrInt(attributes, "calls-to-new-array");
		int callsDeleteArray = getAttrInt(attributes, "calls-to-delete-array");
		mwInfo = new MemWatchInfo(maxBlocks, callsNew, callsDelete, callsNewArray, callsDeleteArray);
	}
}