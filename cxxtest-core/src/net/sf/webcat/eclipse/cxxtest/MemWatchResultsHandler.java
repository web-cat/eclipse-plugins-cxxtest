/*
 *	This file is part of Web-CAT Eclipse Plugins.
 *
 *	Web-CAT is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	Web-CAT is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Web-CAT; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sf.webcat.eclipse.cxxtest;

import java.util.Vector;

import net.sf.webcat.eclipse.cxxtest.internal.model.CxxTestStackFrame;
import net.sf.webcat.eclipse.cxxtest.internal.model.MemWatchInfo;
import net.sf.webcat.eclipse.cxxtest.internal.model.MemWatchLeak;
import net.sf.webcat.eclipse.cxxtest.model.IMemWatchInfo;
import net.sf.webcat.eclipse.cxxtest.model.IMemWatchLeak;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

/**
 * This class is a very simplistic SAX content handler that parses the XML
 * results file generated by our CxxTest XML printer and builds a tree of
 * test suite and test case objects from it.
 */
public class MemWatchResultsHandler extends DefaultHandler
{
	private MemWatchInfo mwInfo = null;

	private Vector leaks = new Vector();

	private boolean insideLeak = false;

	private MemWatchLeak lastLeak = null;
	
	public void startElement(String uri, String localName, String qName,
			Attributes attributes)
	{
		if(localName.equals("summary"))
			startSummary(attributes);
		if(localName.equals("leak"))
			startLeak(attributes);
		else if(insideLeak)
			startStackFrame(attributes);
	}

	public void endElement(String uri, String localName, String qName)
	{
		if(localName.equals("leak"))
			endLeak();
	}
	
	private void startLeak(Attributes attributes)
	{
		MemWatchLeak leak = new MemWatchLeak(attributes);
		leaks.add(leak);
		lastLeak = leak;
		
		insideLeak = true;
	}
	
	private void endLeak()
	{
		insideLeak = false;
		lastLeak = null;
	}

	private void startStackFrame(Attributes attributes)
	{
		String function = attributes.getValue("function");
		String file = null;
		int lineNumber = 0;
		
		String fileLine = attributes.getValue("location");
		if(fileLine != null)
		{
			String[] parts = fileLine.split(":");
			file = parts[0];
			
			if(parts.length > 1)
				lineNumber = Integer.parseInt(parts[1]);
		}
		
		lastLeak.addStackFrame(new CxxTestStackFrame(function, file, lineNumber));
	}

	public IMemWatchInfo getInfo()
	{
		mwInfo.setLeaks((IMemWatchLeak[])leaks.toArray(
				new IMemWatchLeak[leaks.size()]));
		return mwInfo;
	}
	
	private int getAttrInt(Attributes attributes, String name)
	{
		return Integer.parseInt(attributes.getValue(name));
	}

	private void startSummary(Attributes attributes)
	{
		int totalBytes = getAttrInt(attributes, "total-bytes-allocated");
		int maxBytes = getAttrInt(attributes, "max-bytes-in-use");

/*		int maxBlocks = getAttrInt(attributes, "max-blocks");
		int callsNew = getAttrInt(attributes, "calls-to-new");
		int callsDelete = getAttrInt(attributes, "calls-to-delete");
		int callsNewArray = getAttrInt(attributes, "calls-to-new-array");
		int callsDeleteArray = getAttrInt(attributes, "calls-to-delete-array");*/
		
		mwInfo = new MemWatchInfo(totalBytes, maxBytes);
	}
}